{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/darshanchipade/Documents/GitHub/UserFlow/UserFlow/src/app/api/ingestion/enrichment/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\n\nconst backendBaseUrl = process.env.SPRINGBOOT_BASE_URL;\n\nconst safeParse = (payload: string) => {\n  try {\n    return JSON.parse(payload);\n  } catch {\n    return payload;\n  }\n};\n\nconst extractId = (payload: unknown): string | null => {\n  if (typeof payload === \"string\") {\n    return payload.trim().length ? payload.trim() : null;\n  }\n  if (typeof payload === \"object\" && payload !== null) {\n    const candidate =\n      (payload as Record<string, unknown>).id ??\n      (payload as Record<string, unknown>).cleansedDataStoreId ??\n      (payload as Record<string, unknown>).cleansedId;\n    if (typeof candidate === \"string\" && candidate.trim().length) {\n      return candidate.trim();\n    }\n  }\n  return null;\n};\n\nexport async function POST(request: NextRequest) {\n  if (!backendBaseUrl) {\n    return NextResponse.json(\n      { error: \"SPRINGBOOT_BASE_URL is not configured.\" },\n      { status: 500 },\n    );\n  }\n\n  let incoming: unknown;\n  try {\n    incoming = await request.json();\n  } catch {\n    return NextResponse.json(\n      { error: \"Request body must be valid JSON.\" },\n      { status: 400 },\n    );\n  }\n\n  const cleansedId = extractId(incoming);\n  if (!cleansedId) {\n    return NextResponse.json(\n      { error: \"Missing `id`/`cleansedDataStoreId`/`cleansedId` attribute.\" },\n      { status: 400 },\n    );\n  }\n\n  try {\n    const targetUrl = new URL(`/api/enrichment/start/${cleansedId}`, backendBaseUrl);\n    const upstream = await fetch(targetUrl, { method: \"POST\" });\n    const rawBody = await upstream.text();\n    const body = safeParse(rawBody);\n\n    return NextResponse.json(\n      {\n        upstreamStatus: upstream.status,\n        upstreamOk: upstream.ok,\n        body,\n        rawBody,\n      },\n      { status: upstream.status },\n    );\n  } catch (error) {\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error\n            ? error.message\n            : \"Unable to reach Spring Boot backend.\",\n      },\n      { status: 502 },\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,iBAAiB,QAAQ,GAAG,CAAC,mBAAmB;AAEtD,MAAM,YAAY,CAAC;IACjB,IAAI;QACF,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEA,MAAM,YAAY,CAAC;IACjB,IAAI,OAAO,YAAY,UAAU;QAC/B,OAAO,QAAQ,IAAI,GAAG,MAAM,GAAG,QAAQ,IAAI,KAAK;IAClD;IACA,IAAI,OAAO,YAAY,YAAY,YAAY,MAAM;QACnD,MAAM,YACJ,AAAC,QAAoC,EAAE,IACvC,AAAC,QAAoC,mBAAmB,IACxD,AAAC,QAAoC,UAAU;QACjD,IAAI,OAAO,cAAc,YAAY,UAAU,IAAI,GAAG,MAAM,EAAE;YAC5D,OAAO,UAAU,IAAI;QACvB;IACF;IACA,OAAO;AACT;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI,CAAC,gBAAgB;QACnB,OAAO,+LAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAyC,GAClD;YAAE,QAAQ;QAAI;IAElB;IAEA,IAAI;IACJ,IAAI;QACF,WAAW,MAAM,QAAQ,IAAI;IAC/B,EAAE,OAAM;QACN,OAAO,+LAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAmC,GAC5C;YAAE,QAAQ;QAAI;IAElB;IAEA,MAAM,aAAa,UAAU;IAC7B,IAAI,CAAC,YAAY;QACf,OAAO,+LAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA6D,GACtE;YAAE,QAAQ;QAAI;IAElB;IAEA,IAAI;QACF,MAAM,YAAY,IAAI,IAAI,CAAC,sBAAsB,EAAE,YAAY,EAAE;QACjE,MAAM,WAAW,MAAM,MAAM,WAAW;YAAE,QAAQ;QAAO;QACzD,MAAM,UAAU,MAAM,SAAS,IAAI;QACnC,MAAM,OAAO,UAAU;QAEvB,OAAO,+LAAY,CAAC,IAAI,CACtB;YACE,gBAAgB,SAAS,MAAM;YAC/B,YAAY,SAAS,EAAE;YACvB;YACA;QACF,GACA;YAAE,QAAQ,SAAS,MAAM;QAAC;IAE9B,EAAE,OAAO,OAAO;QACd,OAAO,+LAAY,CAAC,IAAI,CACtB;YACE,OACE,iBAAiB,QACb,MAAM,OAAO,GACb;QACR,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}